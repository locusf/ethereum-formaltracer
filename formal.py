from evm import opcode_values as ops
from pylatex import NoEscape,Math
formulae = {
        # Arithmetic
        ops.ADD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]",escape=False),
        ops.MUL: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]",escape=False),
        ops.SUB: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] - \boldsymbol{\mu}_\mathbf{s}[1]",escape=False),
        ops.DIV: Math(data="\\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \\begin{cases}0 & \text{if} \quad \\boldsymbol{\mu}_\mathbf{s}[1] = 0\\\\ \lfloor\\boldsymbol{\mu}_\mathbf{s}[0] \div \\boldsymbol{\mu}_\mathbf{s}[1]\\rfloor & \\text{otherwise}\end{cases}",escape=False),
        ops.SDIV: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ -2^{255} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = -2^{255} \wedge \quad \boldsymbol{\mu}_\mathbf{s}[1] = -1\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]) \lfloor |\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]| \rfloor & \text{otherwise}\end{cases}", escape=False),
        ops.MOD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \boldsymbol{\mu}_\mathbf{s}[0] \bmod \boldsymbol{\mu}_\mathbf{s}[1] & \text{otherwise}\end{cases}",escape=False),
        ops.SMOD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0]) (|\boldsymbol{\mu}_\mathbf{s}[0]| \bmod |\boldsymbol{\mu}_\mathbf{s}[1]|) & \text{otherwise}\end{cases}",escape=False),
        ops.ADDMOD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}",escape=False),
        ops.MULMOD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}", escape=False),
        ops.EXP: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] ^ {\boldsymbol{\mu}_\mathbf{s}[1] }",escape=False),
        ops.SIGNEXTEND: Math(data=r" \forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_t &\text{if} \quad i \leqslant t \quad \text{where} \; t = 256 - 8(\boldsymbol{\mu}_\mathbf{s}[0] + 1) \\ \boldsymbol{\mu}_\mathbf{s}[1]_i &\text{otherwise} \end{cases} \\ \multicolumn{5}{l}{\boldsymbol{\mu}_\mathbf{s}[x]_i gives the ith bit (counting from zero) of \boldsymbol{\mu}_\mathbf{s}[x]", escape=False),
        # Bitwise
        ops.LT: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.GT: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.SLT: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.SGT: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}",escape=False),
        ops.EQ: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.ISZERO: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = 0 \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.AND: Math(data=r"\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \wedge \boldsymbol{\mu}_\mathbf{s}[1]_i", escape=False),
        ops.OR: Math(data=r"\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \vee \boldsymbol{\mu}_\mathbf{s}[1]_i", escape=False),
        ops.XOR: Math(data=r"\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \oplus \boldsymbol{\mu}_\mathbf{s}[1]_i",escape=False),
        ops.NOT: Math(data=r"\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0]_i = 0 \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.BYTE: Math(data=r"\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_{(i + 8\boldsymbol{\mu}_\mathbf{s}[0])} & \text{if} \quad i < 8 \wedge \boldsymbol{\mu}_\mathbf{s}[0] < 32 \\ 0 & \text{otherwise} \end{cases} ", escape=False),
        # Sha3
        ops.SHA3: Math(data=[r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \mathtt{\tiny Keccak}(\boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])",r"\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])"], escape=False),
        # Account
        ops.ADDRESS: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_a", escape=False),
        ops.BALANCE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}\boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0]]_b& \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}] \neq \varnothing\\0&\text{otherwise}\end{cases}", escape=False),
        ops.ORIGIN: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_o", escape=False),
        ops.CALLER: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_s", escape=False),
        ops.CALLVALUE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_v", escape=False),
        ops.CALLDATALOAD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_\mathbf{d}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \quad \text{with} \quad I_\mathbf{d}[x] = 0 \quad \text{if} \quad x \geqslant \lVert I_\mathbf{d} \rVert", escape=False),
        ops.CALLDATASIZE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{d} \rVert", escape=False),
        ops.CALLDATACOPY: Math(data=r"\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv \begin{cases} I_\mathbf{d}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{d} \rVert \\ 0 & \text{otherwise} \end{cases}", escape=False),
        ops.CODESIZE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{b} \rVert",escape=False),
        ops.CODECOPY: Math(data=r"\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{b} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}", escape=False),
        ops.GASPRICE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_p", escape=False),
        ops.EXTCODESIZE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_c \rVert", escape=False),
        ops.EXTCODECOPY: Math(data=r"\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[3] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[1] + i ] \equiv \begin{cases} \mathbf{c}[\boldsymbol{\mu}_\mathbf{s}[2] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] + i < \lVert \mathbf{c} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}",escape=False),
        # Block
        ops.BLOCKHASH: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv P(I_{H_p}, \boldsymbol{\mu}_\mathbf{s}[0], 0)", escape=False),
        ops.COINBASE: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_c",escape=False),
        ops.TIMESTAMP: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_s", escape=False),
        ops.NUMBER: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_i", escape=False),
        ops.DIFFICULTY: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_d", escape=False),
        ops.GASLIMIT: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_l", escape=False),
        #Stack
        ops.POP: Math(data=r"\boldsymbol{\mu}_\mathbf{s}[0] = nil",escape=False),
        ops.MLOAD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \\ \boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })", escape=False),
        ops.MSTORE: Math(data=r"\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \equiv \boldsymbol{\mu}_\mathbf{s}[1]", escape=False),
        ops.MSTORE8: Math(data=r"\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv (\boldsymbol{\mu}_\mathbf{s}[1] \bmod 256)  \\&&&& \boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 1) \div 32 })",escape=False),
        ops.SLOAD: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]]", escape=False),
        ops.SSTORE: Math(data=r"\boldsymbol{\sigma}'[I_a]_\mathbf{s}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv \boldsymbol{\mu}_\mathbf{s}[1]", escape=False),
        ops.JUMP: Math(data=r"J_{\text{\tiny JUMP}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{s}[0] ", escape=False),
        ops.JUMPI: Math(data=r"J_{\text{\tiny JUMPI}}(\boldsymbol{\mu}) \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[0] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \\ \boldsymbol{\mu}_{pc} + 1 & \text{otherwise} \end{cases}", escape=False),
        ops.PC: Math(data=r"""\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{p}""",escape=False),
        ops.MSIZE: Math(data=r"""\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{i}""",escape = False),
        ops.GAS: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{g}",escape=False),

        # Pushes
        ops.PUSH1: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv c(\boldsymbol{\mu}_{pc} + 1)",escape=False),
        ops.PUSH2: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 2) \big)",escape=False),
        ops.PUSH3: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 3) \big)",escape=False),
        ops.PUSH4: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 4) \big)",escape=False),
        ops.PUSH5: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 5) \big)",escape=False),
        ops.PUSH6: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 6) \big)",escape=False),
        ops.PUSH7: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 7) \big)",escape=False),
        ops.PUSH8: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 8) \big)",escape=False),
        ops.PUSH9: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 9) \big)",escape=False),
        ops.PUSH10: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 10) \big)",escape=False),
        ops.PUSH11: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 11) \big)",escape=False),
        ops.PUSH12: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 12) \big)",escape=False),
        ops.PUSH13: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 13) \big)",escape=False),
        ops.PUSH14: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 14) \big)",escape=False),
        ops.PUSH15: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 15) \big)",escape=False),
        ops.PUSH16: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 16) \big)",escape=False),
        ops.PUSH17: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 17) \big)",escape=False),
        ops.PUSH18: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 18) \big)",escape=False),
        ops.PUSH19: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 19) \big)",escape=False),
        ops.PUSH20: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 20) \big)",escape=False),
        ops.PUSH21: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 21) \big)",escape=False),
        ops.PUSH22: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 22) \big)",escape=False),
        ops.PUSH23: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 23) \big)",escape=False),
        ops.PUSH24: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 24) \big)",escape=False),
        ops.PUSH25: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 25) \big)",escape=False),
        ops.PUSH26: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 26) \big)",escape=False),
        ops.PUSH27: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 27) \big)",escape=False),
        ops.PUSH28: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 28) \big)",escape=False),
        ops.PUSH29: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 29) \big)",escape=False),
        ops.PUSH30: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 30) \big)",escape=False),
        ops.PUSH31: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 31) \big)",escape=False),
        ops.PUSH32: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 32) \big)",escape=False),
        # Dup
        ops.DUP1: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.DUP2: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]", escape=False),
        ops.DUP3: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[2]", escape=False),
        ops.DUP4: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[3]", escape=False),
        ops.DUP5: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[4]", escape=False),
        ops.DUP6: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[5]", escape=False),
        ops.DUP7: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[6]", escape=False),
        ops.DUP8: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[7]", escape=False),
        ops.DUP9: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[8]", escape=False),
        ops.DUP10: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[9]", escape=False),
        ops.DUP11: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[10]", escape=False),
        ops.DUP12: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[11]", escape=False),
        ops.DUP13: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[12]", escape=False),
        ops.DUP14: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[13]", escape=False),
        ops.DUP15: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[14]", escape=False),
        ops.DUP16: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[15]", escape=False),
        #swap
        ops.SWAP1: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1] \newline \boldsymbol{\mu}'_\mathbf{s}[1] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP2: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[2] \newline \boldsymbol{\mu}'_\mathbf{s}[2] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP3: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[3] \newline \boldsymbol{\mu}'_\mathbf{s}[3] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP4: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[4] \newline \boldsymbol{\mu}'_\mathbf{s}[4] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP5: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[5] \newline \boldsymbol{\mu}'_\mathbf{s}[5] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP6: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[6] \newline \boldsymbol{\mu}'_\mathbf{s}[6] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP7: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[7] \newline \boldsymbol{\mu}'_\mathbf{s}[7] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP8: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[8] \newline \boldsymbol{\mu}'_\mathbf{s}[8] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP9: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[9] \newline \boldsymbol{\mu}'_\mathbf{s}[9] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP10: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[10] \newline \boldsymbol{\mu}'_\mathbf{s}[10] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP11: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[11] \newline \boldsymbol{\mu}'_\mathbf{s}[11] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP12: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[12] \newline \boldsymbol{\mu}'_\mathbf{s}[12] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP13: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[13] \newline \boldsymbol{\mu}'_\mathbf{s}[13] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP14: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[14] \newline \boldsymbol{\mu}'_\mathbf{s}[14] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP15: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[15] \newline \boldsymbol{\mu}'_\mathbf{s}[15] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        ops.SWAP16: Math(data=r"\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[16] \newline \boldsymbol{\mu}'_\mathbf{s}[16] \equiv \boldsymbol{\mu}_\mathbf{s}[0]", escape=False),
        # system
        ops.CALL: Math(data=r"$\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[3] \dots (\boldsymbol{\mu}_\mathbf{s}[3] + \boldsymbol{\mu}_\mathbf{s}[4] - 1) ]$ \\ $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}, I_a, I_o, t, t,\\ \quad C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}), I_p, \boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge \\ \quad\quad I_e < 1024\end{array}\\ (\boldsymbol{\sigma}, g, \varnothing, ()) & \text{otherwise} \end{cases}$ \\$n \equiv \min(\{ \boldsymbol{\mu}_\mathbf{s}[6], |\mathbf{o}|\})$ \\$\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[5] \dots (\boldsymbol{\mu}_\mathbf{s}[5] + n - 1) ] = \mathbf{o}[0 \dots (n - 1)]$ \\$\boldsymbol{\mu}'_g \equiv \boldsymbol{\mu}_g + g'$ \\$\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\$A' \equiv A \Cup A^+$ \\",escape=False),
        ops.RETURN: Math(data=r"H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots ( \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1 ) ]", escape=False),
        }

def get_formula(fn, comp):
    try:
        return formulae[fn]
    except KeyError:
        return ""
